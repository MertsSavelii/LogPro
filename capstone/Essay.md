# Реферат
## по курсу "Логическое программирование"

### студент: Мерц С.П.

## Заданиеч
4. Как использовать логические языки чтобы научить компьютер играть в шахматы/шашки 

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Вступление

### Что за логические языки?
   
Логические языки - языки программирования в логической парадигме, основанной на автоматическом доказательстве теорем. Процесс программирования в этой парадигме схож с обучением ребёнка. Мы задаём правила и утверждения, на основе которых программа может поверять входные данные на истинность путём сопоставления.

Первым представителем является язык Planner, в котором результат обработки данных получался из заданных правил перевода (совокупность которых называется планом, откуда и название). Он был разработан с целью понижения требования к ресурсам с помощью бэктрекинга и возможности вывода фактов без активного использования стэка. Затем был разработан  Prolog, пожалуй самый известный и популярный логический язык программирования. Он не требовал "плана" и был в каком-то смысле упрощением Planner.

От Planner произошли такие языки, как  QA-4, Popler, Conniver и QLISP.
От Prolog Mercury, Visual Prolog, Oz и Fril. 
Так же на базе Planner был разработаны несколько других языков программирования не основанных на бэктрекинге, например Ether.

### Язык логического программирования "Prolog"

Prolog - язык логического программирования, который похож на язык предикатов, представляющий собой подмножество логики предикатов первого порядка, например 
|Название операции |Обозначение в логике предикатов|Обозначение в Prolog|
|------------------|-------------------------------|--------------------|
| и                |  &                            |  ,                 |
| или              |  v                            |  ;                 |
| если             |  =>                           |  :-                |
| не               |  ~                            |  not               |

Программа Prolog отличается от императивных программ привычных большинству и близок к модели Маркова, так как не содержит управляющих конструкций (усоловных опеаторов, операторов цикала и т. д.). Она является некоторой моделью какой-то части предметной области. В ней не надо задавать алгоритм как чёткую последовательность действий, необходимо описать некоторую задачу и правила, через утверждения, по которым программа может получить результат.
Основные механизмы в языке: сопоставление с образцом, древовидное представление структур данных и автоматический перебор с возвратами.

Утверждения в Prolog:
Программа является набором правил продукций с предикатами в левой и правой части. Факты - правила без посылки в продукции. Вся система образует своеобразную базу знаний. Запрос является вопросом поставленной задачи, для которого интересна истинность. Если в запросе нет переменных, то ответом будет сухое true/false (Prolog лучше всех знает как выполнять true/false упражнения в английском языке), если же есть, то ищется их интерпретация, при которой запрос был бы истинным.

На сегодня создано достаточно множество реализаций языка Пролог, причэм некоторые очень сильно отличаются друг от друга, вот основные: SWI Prolog, Turbo Prolog, Visual Prolog, GNU Prolog и т.д.

Какие задачи можно решать на Prolog? Ну вообще любые. Prlog это полный по Тьюрингу язык программирования, но он не заточен под вычислительные задачи и программировать их на нём не нужно. Зато очень удобно решать задачи со сложными структурами данных. В Prolog очень просто представлять деревья выражений, а список вообще является основной структурой данных, какой является массив в императивных языках. Благодаря этому хорошо решаются задачи с символьными преобразованиями, с обработкой естественного и искусственного языка, искусственного интеллекта,построение экспертных систем или игры с эвристиками (например, шахматы или шашки), о которых далее пойдэт речь.

## Как программа играет в шахматы
  
### Вспомним шахматы

Шахматы - настольная игра, сочетающая в себе элементы искусства, науки и спорта, правила которой сложились к XV веку. Играют обычно два игрока на шестидесяти четырёх клеточной доске.
Правила игры пожалуй опущу, но расскажу о менее известных терминах.

#### Особые ходы:
* Рокировка - при условии того, что король и одна из ладей того же цвета не двигались с начала игры, король и эта ладья могут в один ход одновременно сменить положение (рокироваться). При рокировке король сдвигается на две клетки по направлению к ладье, а ладья ставится на поле между начальной и конечной позицией короля. 

* Взятие на проходе - пешка, совершающая ход на две клетки через битое поле, находящееся под ударом пешки противника, ответным ходом она может быть взята этой пешкой противника. При этом пешка противника перемещается на битое поле, а взятая пешка снимается с доски.

#### Шах, мат, пат:
* Король, находящийся на битом поле, называется «стоящим под шахом».
* Если король игрока «стоящит под шахом» и игрок не может совершить ни одного хода, для устранения этотого шаха, этот игрок называется «получившим мат» и, соответственно, он терпит поражение. В достижение этого состояния противника и заключена цель игры.
* Если игрок на своём ходе не имеет возможности сделать ни одного хода по правилам, но король игрока не находится под шахом, такая ситуация называется пат.

#### Этапы партии
* Дебют - начальная стадия партии, идёт первые 10—15 ходов. В дебюте основной задачей игроков является мобилизация собственных сил, планирование и подготовка к непосредственному столкновению с оппонентом и начало такого столкновения. 
* Миттельшпиль - середина игры. Стадия, начинающаяся после дебюта. Именно в ней обычно происходят основные события шахматной партии (ситуации, когда выигрыш достигается ещё в дебюте, очень редки). Характеризуется большим количеством фигур на доске, активной сменой позиции, атаками и контратаками, соперничеством за ключевые пункты, в первую очередь — за центр. Партия может завершиться уже в этой стадии, обычно такое происходит, когда одна из сторон проводит успешную комбинацию. В противном случае после взятия большего числа фигур партия переходит в эндшпиль.
* Ендшпиль - заключительная стадия игры. Характеризуется небольшим количеством фигур на доске. В эндшпиле резко возрастает роль пешек и короля. Часто основной темой игры в эндшпиле становится проведение проходных пешек. Эндшпиль заканчивается либо победой одной из сторон, либо достижением положения, когда победа в принципе невозможна. В последнем случае заключается ничья.

## Программирования шахмат

### Немного истории развития шахматных программ

Первой машиной для игры в шахматы можно считать, построеную в 1769 венгерским инженером бароном Вольфгангом фон Компеленом, созданную для развлечения королевы Марии-Терезии. Во время демонстрации, изобретатель открывал дверцы шкафа, на котором стояла шахматная доска, где можно было увидеть сложный механизм с множеством узлов. На самом деле внутри сидел сильный шахматист, скрытый от наблюдателей системой зеркал и перегородок.

Ещё одной одной интересной "человечиской" машиной была "бумажная машина Тьюринга". Этот алгоритм написал Алан Тьюринг в 1951 году. Уникалльностью данного алгоритма, являлось то, что в качестве вычислительной машины выступал сам изобретатель. Алану требовалось более получаса, чтобы сделать один ход. Удивительно, но сохранилась одна из партий, где "бумажная машина Тьюринга" проиграла одному из своих колег создателя.

В 1996 произошо знаменитое и, по моему мнению, неотвратимое событие, впервые программа Deep Blu смогла выиграть партию у чемпиона мира (Гарри Каспарова) в турнирных условиях, но проиграла матч. В 1997 произошёл матч-реванш, искуственный интелект превзашёл человека и в последующем разрыв только увеличивался.

Можно ещё долго перечеслять интересные программы для игры в шахматы. Хорошо рассказал о них Евгений Корнилов в своей книге "Программирование шахмат и других логических игр."

### Основы программирования шахмат

Многие, как и я до начала написания данного эссэ, полагают, что компьютер просто хранит огромное множество различных ходов и выбирает подходящий для данной ситуаци. На самом же деле уже к 4 ходу, где под 1 ходом подразумевается ход белых и чёрных фигур, а под полуходом только одной стороны, дерево ходов содержит почти 140 милионов узлов, что уже тяжело поддаётся анализу в приемлимые временные промежутки.

Современные программы состоят из генератора ходов, оценивающей функции и минимаксную процедуру или её модификацию негамаксную, а так же всевозможные оптимизации. Работа программы проста: генератор генерирует на определённую глубину, оцинивающая функция оценивает каждый полученный ход, минимакс находит оптимальную очереёдность ходов, оптимизации оптимизируют полученное дерево с возможным продолжением генерации в глубь.

Генератор проверяет возможность хода и, если ход возможен выводит его. Генератор теоретически получает все возможные ходы и является условно корекурсивным алгоритмом.

Функция оценки позиции на вход получает сгенерированную позицию на доске и оценивает её по всевозможным критериям, чем выше балл - тем больше шансы на выигрышь. Хорошоую оценивающую функцию очень тяжело написать ибо необходимо учитывать огромное количество факторов, в настройке которых ей раньше помогал человек, а сейчас гораздо лучшего результата добивается с помощью методов машинного обучения.

Минимакс начиная с листьев дерева, для которых известна их оценка, подниммается на верх выбирая оптимальный для текущего игрлка ход. Негомакс меняетзнак всех оценок и выбирает путь по максимальным из них.
 #### Оптимизации

## Шахматы на Прологе

   

## Вывод

   

 ## Список литературы

1. Интернет источник - википедия
2. Сошников Д.В. - "Парадигма логического программирования."
3. Корнилов Е.Н. "Программирование шахмат и других логических игр."
4. Петер Флах - "Машинное обучение. Наука и искусство построения алгоритмов, которые извлекают знания из данных."
5.  Интернет источник - ИНТУИТ